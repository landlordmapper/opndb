from concurrent.futures import as_completed
from concurrent.futures.thread import ThreadPoolExecutor
import time
import traceback

import pandas as pd
import requests as req

from opndb.constants.base import GEOCODIO_URL
from opndb.types.base import (
    RawAddress,
    GeocodioResult,
    GeocodioResponse,
    GeocodioResultProcessed,
    GeocodioResultFlat
)
from opndb.services.dataframe.base import (
    DataFrameOpsBase as ops_df,
    DataFrameBaseCleaners as clean_df
)
from opndb.utils import UtilsBase as utils


class AddressBase:

    # todo: get this out of here - all file processing should be handled in the workflow

    def __init__(self):
        self.geocodio_api_key = ""

    @classmethod
    def get_unique_addresses(cls, df: pd.DataFrame, addr_cols: RawAddress):
        """Returns all unique addresses found in the dataframe."""
        pass

    @classmethod
    def add_is_pobox_bool(cls):
        """Adds 'is_pobox' column to the dataframe generated by get_unique_addresses()."""
        pass

    @classmethod
    def format_pobox(cls):
        """Runs PO box formatter on raw address and adds to DATA_ROOT/processed/validated_addrs.csv"""
        pass

    @classmethod
    def save_unvalidated_addrs_initial(cls, dfs: list[pd.DataFrame]) -> pd.DataFrame:
        """
        Saves initial unvalidated address file to DATA_ROOT/processed/unvalidated_addrs. Run only once, after the raw
        data has been cleaned & validated but BEFORE address validation.
        """
        pass

    @classmethod
    def save_validated_addrs_initial(cls, df: pd.DataFrame) -> str:
        return ops_df.save_df(df, cls.validated_addrs_path)

    @classmethod
    def call_geocodio(cls, api_key: str, address_search_string: str) -> list[GeocodioResult] | None:
        """Executes Geocodio API call."""
        if api_key == "":
            raise Exception("No API key detected.")
        url: str = GEOCODIO_URL + api_key + "&q=" + address_search_string
        res: req.Response = req.get(url)
        if res.status_code == 200:
            data: GeocodioResponse = res.json()
            return data["results"]
        else:
            return None

    @classmethod
    def save_geocodio_partial(cls, results: list[dict]):
        timestamp = utils.get_timestamp()
        df_partial = pd.DataFrame(results)
        ops_df.save_df(df_partial, cls.gcd_partials_dir_path / f"partial_geocodio_({timestamp}).csv")

    @classmethod
    def check_matching_addrs(cls, df: pd.DataFrame) -> bool:
        """
        Check whether the formatted addresses in the GeocodioResult objects are identical. Returns 'True' if they are,
        'False' if they aren't.
        """
        formatted_addrs = set(df["formatted_address"].tolist())  # todo: add 'formatted_address' column to dataframe
        return len(formatted_addrs) == 1

    @classmethod
    def flatten_geocodio_result(cls, result: GeocodioResult) -> GeocodioResultFlat:
        """
        Flattens geocodio result by moving lat, lng, accuracy and formatted_address into the highest level key/value
        pair nesting.
        """
        address_components = result.get("address_components", {})
        location = result.get("location", {})
        return {
            "number": address_components.get("number", ""),
            "predirectional": address_components.get("predirectional", ""),
            "prefix": address_components.get("prefix", ""),
            "street": address_components.get("street", ""),
            "suffix": address_components.get("suffix", ""),
            "postdirectional": address_components.get("postdirectional", ""),
            "secondaryunit": address_components.get("secondaryunit", ""),
            "secondarynumber": address_components.get("secondarynumber", ""),
            "city": address_components.get("city", ""),
            "county": address_components.get("county", ""),
            "state": address_components.get("state", ""),
            "zip": address_components.get("zip", ""),
            "country": address_components.get("country", ""),
            "lng": location.get("lng", ""),
            "lat": location.get("lat", ""),
            "accuracy": result.get("accuracy", ""),
            "formatted_address": result.get("formatted_address", "")
        }

    # @classmethod
    # def get_flatted_geocodio_result_from_df(cls, row: pd.Series) -> GeocodioResultFlat:
    #     return {
    #         "number": row["number"],
    #         "predirectional": row["predirectional"],
    #         "prefix": row["prefix"],
    #         "street": row["street"],
    #         "suffix": row["suffix"],
    #         "postdirectional": row["postdirectional"],
    #         "secondaryunit": row["secondaryunit"],
    #         "secondarynumber": row["secondarynumber"],
    #         "city": row["city"],
    #         "county": row["county"],
    #         "state": row["state"],
    #         "zip": row["zip"],
    #         "country": row["country"],
    #         "lng": row["lng"],
    #         "lat": row["lat"],
    #         "accuracy": row["accuracy"],
    #         "formatted_address": row["formatted_address"],
    #     }

    @classmethod
    def apply_filters(cls, raw_addr: RawAddress, df: pd.DataFrame) -> pd.DataFrame | None:

        """Filters geocodio results by street number and zip code. Additional filters to be added in the future."""

        # extract individual pieces of raw address
        addr_raw_split = raw_addr["complete_addr"].split(",")

        if "street" in raw_addr.keys():
            number_raw: str = raw_addr["street"].split()[0]
        else:
            number_raw = addr_raw_split[0].split()[0]

        if "zip" in raw_addr.keys():
            zip_raw: str = raw_addr["zip"]
        else:
            zip_raw = addr_raw_split[-1]

        # FILTER 1: missing street numbers
        # filter out results with no street number - if none have street number, return object as is
        df_street_no: pd.DataFrame = df[df["number"] != ""]
        if df_street_no.empty:
            return None
        if len(df_street_no) == 1 or cls.check_matching_addrs(df_street_no):
            return df_street_no.iloc[[0]]

        # FILTER 2: multiple street numbers
        # print("filtering street number...")
        df_number = df[df["number"] == number_raw]
        if df_number.empty:
            return df
        if len(df_number) == 1 or cls.check_matching_addrs(df_number):
            return df_number.iloc[[0]]

        # FILTER 3: zip code
        # print("filtering zip code...")
        df_zip = df_number[df_number["zip"] == zip_raw]
        if df_zip.empty:
            return df_number
        if len(df_zip) == 1 or cls.check_matching_addrs(df_zip):
            return df_zip.iloc[[0]]
        else:
            return df_zip

        # FILTER 3: street name
        # print("filtering street name...")
        # streets = list(df_zip["street"].unique())
        # df_street = pd.DataFrame()
        # for street in streets:
        #     street_split = street.split()
        #     if all(word in addr_sc_split for word in street_split):
        #         df_street = df_zip[df_zip[cls.va.GCD_STREET] == street]
        #         break
        # if df_street.empty:
        #     unvalidated_rows.extend(df_zip.to_dict("records"))
        #     return
        # if len(df_street) == 1 or cls.check_matching_addrs(df_street):
        #     validated_rows.append(df_street.iloc[0].to_dict())
        #     return

        # FILTER 4: city name
        # print("filtering city name...")
        # city_sc = df_street.iloc[0][cls.va.TAXPAYER_CITY]
        # df_city = df_street[df_street[cls.va.TAXPAYER_CITY] == city_sc]
        # if df_city.empty:
        #     unvalidated_rows.extend(df_street.to_dict("records"))
        #     return
        # if len(df_city) == 1 or cls.check_matching_addrs(df_city):
        #     validated_rows.append(df_city.iloc[0].to_dict())
        #     return

        # FILTER 5: predirectional
        # print("filtering predirectional...")
        # predirs = df_city[cls.va.GCD_PREDIRECTIONAL].unique().tolist()
        # df_predir = df_city[df_city.apply(lambda row: cls.contains_predirectional(
        #     row[cls.va.TAXPAYER_ADDRESS],
        #     predirs
        # ), axis=1)]
        # if df_predir.empty:
        #     unvalidated_rows.extend(df_city.to_dict("records"))
        #     return
        # if len(df_predir) == 1 or cls.check_matching_addrs(df_predir):
        #     validated_rows.append(df_predir.iloc[0].to_dict())
        #     return

        # FILTER 6: street suffix
        # print("filtering street suffix...")
        # df_suffix = df_predir[df_predir[cls.va.GCD_SUFFIX].isin(addr_sc_split)]
        # if df_suffix.empty:
        #     unvalidated_rows.extend(df_predir.to_dict("records"))
        #     return
        # if len(df_suffix) == 1 or cls.check_matching_addrs(df_suffix):
        #     validated_rows.append(df_suffix.iloc[0].to_dict())
        #     return
        # unvalidated_rows.extend(df_predir.to_dict("records"))

    @classmethod
    def process_geocodio_results(
        cls,
        raw_addr: RawAddress,
        results: list[GeocodioResultFlat]
    ) -> GeocodioResultProcessed:

        """
        Processes results returned by call_geocodio(). Returns data object containing the raw address information, the
        original results object and a list of parsed results.
        """

        # instantiate GeocodioResultsProcessed object with empty results_parsed
        results_processed: GeocodioResultProcessed = {
            "raw_addr": raw_addr,
            "results": results,
            "results_parsed": None,
        }

        # if no results found, return object as is
        if len(results) == 0:
            return results_processed

        # convert results to df and perform basic cleaning
        df_results: pd.DataFrame = pd.DataFrame(results, dtype=str)
        df_results = df_results.fillna("")
        df_results = clean_df.make_upper(df_results)

        # run remaining results through filters
        df_filtered = cls.apply_filters(df_results)

        if len(df_filtered) == 1:
            results_processed["results_parsed"] = [df_filtered.iloc[0].to_dict()]
        elif len(df_filtered) > 1:
            results_processed["results_parsed"] = df_filtered.to_dict("records")

        return results_processed

    @classmethod
    def add_validated_addr_from_geocodio(cls, addr: GeocodioResultFlat):
        """Adds Geocodio result object to DATA_ROOT/geocodio/gcd_validated.csv"""
        # converts geocodio result into panderas object
        # adds panderas object to validated address dataframe
        pass

    @classmethod
    def add_unvalidated_addr_from_geocodio(cls, results: list[GeocodioResultFlat] | None):
        """Adds unfiltered Geocodio results objects to 'DATA_ROOT/geocodio/gcd_unvalidated.csv'."""
        # if results is None:
            # add row with empty values for the GeocodioResultFlat object
        # else:
            # for each result, add rows to gcd_unvalidated.csv
        pass

    @classmethod
    def add_failed_geocodio_row(cls, raw_addr: RawAddress):
        """Adds row to 'DATA_ROOT/geocodio/gcd_failed.csv'."""
        pass

    @classmethod
    def run_geocodio(cls, api_key: str, df_addrs: pd.DataFrame, addr_col: str, interval: int = 50):
        """
        Executes Geocodio API calls for raw, unvalidated addresses.

        :param api_key: user's unique Geocodio API key
        :param df_addrs: Dataframe of rows containing raw address data, with one row per unique address.
        :param addr_col: Column name containing the addresses to be validated..
        :param interval: Optional interval setting to control how many Geocodio calls should trigger a partial save.
        :return:
        """
        try:
            gcd_results = []
            start_time = time.time()
            with ThreadPoolExecutor(max_workers=10) as executor:
                # store all unique addresses from dataframe into future object
                futures = {}
                for i, row in df_addrs.iterrows():
                    future = executor.submit(cls.call_geocodio, api_key, row[addr_col])
                    futures[future] = (i, row)
                # loop through futures object, executing geocodio calls for each one
                for future in as_completed(futures):  # todo: add progress bar visualization
                    try:
                        i, row = futures[future]
                        raw_addr: RawAddress = row.to_dict()  # create RawAddress object from dataframe row
                        results: list[GeocodioResult] = future.result()  # fetch results returned by call_geocodio()
                        # flatten geocodio results to include lat, lng, accuracy and formatted address
                        flattened_results: list[GeocodioResultFlat] = [cls.flatten_geocodio_result(result) for result in results]
                        if results:  # API call succeeded, begin processing results
                            results_processed: GeocodioResultProcessed = cls.process_geocodio_results(
                                raw_addr,
                                flattened_results
                            )
                            # validation & filtering successful, add to master validated address dataset
                            if len(results_processed["results_parsed"]) == 1:
                                cls.add_validated_addr_from_geocodio(results_processed["results_parsed"][0])
                            # could not filter down to 1 result,
                            else:
                                cls.add_unvalidated_addr_from_geocodio(results_processed["results_parsed"])
                            # add all results and their associated raw address to the partial
                            for result in flattened_results:
                                gcd_results.append({**raw_addr, **result})  # include raw address data in result row
                        else:
                            cls.add_failed_geocodio_row(raw_addr)
                            gcd_results.append(raw_addr)
                        # save geocodio partial and empty out gcd_results
                        if interval is not None and len(gcd_results) >= interval:
                            cls.save_geocodio_partial(gcd_results)
                            gcd_results = []
                    except Exception as e:
                        print(f"Error: {e}")
                        print(traceback.format_exc())
                if interval is not None and gcd_results:
                    cls.save_geocodio_partial(gcd_results)
            if interval is None:
                cls.save_geocodio_partial(gcd_results)
            # log time
            end_time = time.time()
            print(f"Elapsed time: {round((end_time - start_time), 2)} minutes")
        except Exception as e:
            print(f"Error: {e}")
            print(traceback.format_exc())

    @classmethod
    def add_to_validated_addrs(cls):
        """
        Saves validated addresses from 'DATA_ROOT/geocodio/gcd_validated.csv' to
        'DATA_ROOT/processed/validated_addrs.csv'.
        """
        pass

    @classmethod
    def removes_from_unvalidated_addrs(cls):
        """Removes validated addresses from 'DATA_ROOT/processed/unvalidated_addrs.csv'"""
        pass

    @classmethod
    def clean_poboxes(cls, df: pd.DataFrame):
        """Cleans up and standardizes PO Box addresses"""
        pass

    @classmethod
    def validate_poboxes(cls, df: pd.DataFrame):
        """Checks for valid zip codes and city names in cleaned PO Box values."""
        pass

    @classmethod
    def get_full_address(
        cls,
        row: pd.Series,
        df_cols: list[str],
        full_addr_key: str,
    ) -> str:
        """
        Returns concatenated string containing all address components. Accounts for missing city and state address
        fields.

        NOTE: Column validation should already have happened at this point, so this should NOT throw a key
        error for missing columns.

        NOTE: Commas are added between state and zip code to allow for splitting.

        :param row: Dataframe row containing address fields
        :param df_cols: List of column names associated with the row
        :param full_addr_key: Key to prefix address columns (ex: "tax" > "tax_street", "president" > "president_street", etc.)
        :param raw_clean_prefix: Optional prefix string to specify address column names (ex: "clean" > "clean_tax_city", "raw" > "raw_agent_street")
        """
        street: str = f"{full_addr_key}_street"
        city: str = f"{full_addr_key}_city"
        state: str = f"{full_addr_key}_state"
        zip_: str = f"{full_addr_key}_zip"
        address_fields: list[str] = [street, city, state, zip_]
        # if no specific address fields are found,
        if all(field not in df_cols for field in address_fields):
            return f"{full_addr_key}_address"
        # if all address fields are present, concatenate like normal
        elif all(field in df_cols for field in address_fields):
            return f"{row[street]}, {row[city]}, {row[state]}, {row[zip_]}"
        # if city or state fields are missing, return value accordingly
        elif city not in df_cols and state not in df_cols:
            return f"{row[street]}, {row[zip_]}"
        elif city not in df_cols:
            return f"{row[street]}, {row[state]}, {row[zip_]}"
        elif state not in df_cols:
            return f"{row[street]}, {row[city]}, {row[zip_]}"
        else:
            raise f"full address generation problem. row: {row}"


class AddressValidatorBase(AddressBase):

    """Handles operations that add to and remove from the master validated & unvalidated address files."""

    def __init__(self):
        super().__init__()
        self.df_validated: pd.DataFrame = ops_df.load_df(self.validated_addrs_path, str)
        self.df_unvalidated: pd.DataFrame = ops_df.load_df(self.unvalidated_addrs_path, str)

    def add_to_df_validated(self):
        # pass row of validated address data - pandera object?
        pass

    def remove_from_df_unvalidated(self):
        # pass index of row to be removed as argument
        pass


    def save(self) -> dict[str, str]:
        validated_path = ops_df.save_df(self.df_validated, self.validated_addrs_path)
        unvalidated_path = ops_df.save_df(self.df_unvalidated, self.unvalidated_addrs_path)
        return {
            "validated_path": validated_path,
            "unvalidated_path": unvalidated_path,
        }

